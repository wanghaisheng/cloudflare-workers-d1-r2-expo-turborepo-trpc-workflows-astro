# 新需求实现与协作规范

## 目录

- [开发流程概述](#开发流程概述)
- [Schema变更规范](#schema变更规范)
- [前端页面开发规范](#前端页面开发规范)
- [API与服务层开发规范](#api与服务层开发规范)
- [多人协作冲突避免策略](#多人协作冲突避免策略)
- [命名与路径规范](#命名与路径规范)
- [测试与Mock策略](#测试与mock策略)

## 开发流程概述

新功能开发遵循以下标准流程：

1. **需求分析与任务拆分**
   - 在Issue中创建需求描述，包含功能点、UI设计参考和验收标准
   - 将需求拆分为数据模型变更、API实现、UI开发等子任务

2. **分支管理**
   - 从`main`分支创建功能分支，命名格式：`feature/[功能名称]`
   - Bug修复使用`fix/[问题简述]`格式

3. **开发顺序**
   - 数据库Schema变更 → API/Service实现 → 前端UI开发 → 测试
   - 每个步骤完成后在PR中更新进度

4. **代码审查与合并**
   - 提交PR前运行完整测试套件
   - 至少需要一名团队成员审查通过
   - 合并后删除功能分支

## Schema变更规范

### 数据库Schema变更流程

1. **Schema定义**
   - 所有表结构定义集中在`packages/db/src/schema.ts`文件中
   - 使用Drizzle ORM的类型安全定义方式

2. **迁移文件生成**
   - 修改schema后，运行迁移命令生成迁移文件：
     ```bash
     pnpm db:generate
     ```
   - 检查生成的迁移文件确保变更符合预期

3. **迁移执行**
   - 本地测试环境执行迁移：
     ```bash
     pnpm db:migrate
     ```
   - 提交PR时，包含schema变更和对应的迁移文件

### Schema变更注意事项

- **向后兼容**: 尽量采用添加新字段而非修改现有字段的方式
- **默认值处理**: 为新增的非空字段提供合理的默认值
- **索引考虑**: 根据查询模式为频繁查询的字段添加索引
- **关系定义**: 明确定义表间关系，使用外键约束

### Schema变更文档

每次Schema变更需在PR描述中包含：

- 变更的表和字段列表
- 变更原因和影响范围
- 是否需要数据迁移脚本
- 相关的API变更

## 前端页面开发规范

### Expo移动应用开发

1. **页面组织**
   - 页面文件放置在`apps/expo/app/`目录下
   - 使用目录路由结构，每个路由对应一个目录
   - 页面组件使用`page.tsx`命名

2. **组件开发**
   - 共享组件放在`apps/expo/components/`目录
   - 组件采用功能分类组织，如`ui/`, `forms/`, `layout/`等
   - 复杂组件拆分为多个小组件，便于维护和测试

3. **状态管理**
   - 使用React Context或Zustand管理全局状态
   - 页面级状态使用React hooks管理
   - 避免过度使用全局状态，优先考虑组件内状态和props传递

### Astro网站开发

1. **页面结构**
   - 页面文件放在`apps/astro/src/pages/`目录
   - 使用Astro组件(.astro)构建静态部分
   - 交互部分使用React组件(.tsx)实现

2. **样式管理**
   - 使用Tailwind CSS进行样式设计
   - 遵循移动优先的响应式设计原则
   - 复杂组件可使用CSS Module或styled-components

## API与服务层开发规范

### tRPC路由开发

1. **路由组织**
   - 路由定义放在`packages/trpc/src/router/`目录下
   - 按功能模块组织路由文件，如`user.ts`, `content.ts`等
   - 在`root.ts`中合并所有路由

2. **输入验证**
   - 使用Zod进行输入参数验证
   - 为每个过程定义明确的输入schema
   - 错误消息应友好且具有指导性

3. **错误处理**
   - 使用tRPC的错误处理机制，定义清晰的错误类型
   - 区分客户端错误和服务器错误
   - 避免在客户端暴露敏感错误信息

### 服务层实现

1. **服务组织**
   - 业务逻辑实现在`apps/apiservice/src/services/`目录下
   - 按领域模型组织服务，如`UserService`, `ContentService`等
   - 服务间依赖通过依赖注入管理

2. **数据访问**
   - 使用Drizzle ORM进行数据库操作
   - 复杂查询封装为可重用的函数
   - 事务操作确保数据一致性

3. **外部API集成**
   - API客户端封装在`apps/apiservice/src/clients/`目录下
   - 使用适当的重试和错误处理机制
   - 缓存策略减少外部API调用

## 多人协作冲突避免策略

### 任务认领与协调

1. **任务认领**
   - 在开始工作前，在Issue中认领任务
   - 更新Issue状态为"In Progress"
   - 标注预计完成时间

2. **进度同步**
   - 每日在团队沟通渠道更新进度
   - 遇到阻碍及时寻求帮助
   - 完成重要里程碑时通知团队

### 代码冲突预防

1. **频繁同步主分支**
   - 每天至少一次从main分支拉取最新代码
   - 解决冲突后再继续开发

2. **模块化开发**
   - 尽量减少对共享文件的修改
   - 新功能优先考虑添加新文件而非修改现有文件
   - 大型重构提前通知团队并协调时间

3. **Schema变更协调**
   - Schema变更计划提前在团队会议中讨论
   - 一次PR中只包含相关的Schema变更
   - 变更后及时通知团队更新本地数据库

### 文档同步

1. **API文档**
   - 新API添加后更新API文档
   - 使用tRPC的类型生成工具自动生成文档

2. **Schema文档**
   - 重要字段添加注释说明用途
   - 维护ER图反映最新的数据模型

3. **README更新**
   - 新功能或配置变更后更新README
   - 保持安装和开发指南的最新状态

## 命名与路径规范

### 命名约定

1. **文件命名**
   - React组件: PascalCase (如`UserProfile.tsx`)
   - 工具函数: camelCase (如`formatDate.ts`)
   - 常量: UPPER_SNAKE_CASE (如`API_ENDPOINTS.ts`)
   - 类型定义: PascalCase, 以T或I开头 (如`TUser`, `IUserService`)

2. **变量命名**
   - 变量和函数: camelCase
   - 组件Props: PascalCase (如`UserProfileProps`)
   - 布尔值变量: 使用is/has/should前缀 (如`isLoading`, `hasError`)

3. **API命名**
   - 查询: get开头 (如`getUser`, `getUserPosts`)
   - 修改: create/update/delete开头 (如`createPost`, `updateProfile`)
   - 列表: 使用复数形式 (如`getPosts`, `getComments`)

### 路径规范

1. **导入路径**
   - 使用别名简化导入路径 (如`@/components`, `@/utils`)
   - 避免使用相对路径超过两级 (如`../../components`)
   - 按类别组织导入语句，内置模块优先

2. **资源路径**
   - 静态资源放在`public/`或`assets/`目录
   - 图片按功能模块组织子目录
   - 使用CDN路径访问生产环境资源

## 测试与Mock策略

### 测试环境配置

1. **本地测试环境**
   - 使用wrangler开发服务器模拟Cloudflare环境
   - 本地D1数据库用于开发测试

2. **CI测试环境**
   - GitHub Actions运行自动化测试
   - 使用测试专用的D1数据库实例

### Mock策略

1. **API Mock**
   - 使用MSW模拟API响应
   - 在`mocks/`目录定义模拟处理程序
   - 提供默认数据集用于开发和测试

2. **环境变量降级**
   - 定义开发环境专用的配置
   - 提供降级服务模拟第三方API

通过遵循以上规范，团队可以高效协作，减少冲突，保持代码质量和一致性，加速新功能的开发和交付。